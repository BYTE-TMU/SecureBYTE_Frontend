# SecureBYTE Frontend - Cursor Rules

## 🎯 Project Overview
This is a React 19 frontend application for SecureBYTE, a secure code review platform. The frontend uses Firebase Authentication, communicates with a Flask backend API, and provides project and submission management with real-time updates.

## 🏗️ Architecture Guidelines

### Component Structure
- **Current State**: Single large `App.jsx` component (745 lines)
- **Target**: Break down into smaller, focused components
- **Component Hierarchy**: App → Auth → ProjectList → SubmissionList → Forms
- **State Management**: Use React hooks (useState, useEffect) consistently

### File Organization
```
src/
├── components/          # Reusable UI components
│   ├── Auth/
│   ├── Projects/
│   ├── Submissions/
│   └── common/
├── hooks/              # Custom React hooks
├── services/           # API and Firebase services
├── utils/              # Helper functions
├── styles/             # CSS/styling files
└── App.jsx            # Main application component
```

## 🎨 UI/UX Standards

### Styling Approach
- **Current**: Inline styles (needs refactoring)
- **Target**: CSS modules or styled-components
- **Design System**: Consistent color palette, spacing, typography
- **Responsive**: Mobile-first design approach

### Color Scheme
```css
/* Primary Colors */
--primary-blue: #007acc;
--secondary-gray: #666;
--success-green: #28a745;
--danger-red: #dc3545;
--warning-orange: #ffc107;

/* Background Colors */
--bg-dark: rgba(0,0,0,0.5);
--bg-light: rgba(255,255,255,0.1);
--bg-code: rgba(0,0,0,0.3);

/* Text Colors */
--text-primary: #fff;
--text-secondary: #ccc;
--text-muted: #999;
```

### Component Patterns
- Use consistent button styles and hover states
- Implement proper form validation and error states
- Add loading states for async operations
- Use consistent spacing and typography

## 🔐 Authentication & Security

### Firebase Integration
- Use Firebase Auth for user authentication
- Support email/password and Google OAuth
- Handle authentication state changes properly
- Secure user-specific API calls with user UID

### API Security
- Always include user authentication in API calls
- Validate user permissions before operations
- Handle authentication errors gracefully
- Don't expose sensitive data in UI

### Input Validation
- Validate form inputs before submission
- Show clear error messages to users
- Sanitize user inputs to prevent XSS
- Implement proper form validation patterns

## 📝 Code Standards

### React Best Practices
- Use functional components with hooks
- Follow React naming conventions (PascalCase for components)
- Implement proper prop validation
- Use React.memo for performance optimization where needed

### JavaScript Standards
- Use ES6+ features (arrow functions, destructuring, etc.)
- Follow consistent naming conventions
- Use async/await for API calls
- Implement proper error handling

### State Management
- Use useState for local component state
- Use useEffect for side effects
- Consider Context API for global state
- Avoid prop drilling by using proper state lifting

## 🚀 Development Workflow

### Component Development
1. Start with functional component structure
2. Add state management with hooks
3. Implement event handlers
4. Add styling and responsive design
5. Test with different data scenarios
6. Add error handling and loading states

### API Integration
- Use axios for HTTP requests
- Implement proper error handling
- Add loading states for async operations
- Cache responses where appropriate
- Handle network errors gracefully

### Testing Strategy
- Test component rendering
- Test user interactions
- Test API integration
- Test error scenarios
- Test responsive design

## 🔧 Dependencies & Configuration

### Required Packages
```json
{
  "react": "^19.1.0",
  "react-dom": "^19.1.0",
  "firebase": "^12.0.0",
  "axios": "^1.10.0"
}
```

### Environment Variables
```env
VITE_FIREBASE_API_KEY=***
VITE_FIREBASE_AUTH_DOMAIN=***
VITE_FIREBASE_PROJECT_ID=***
VITE_FIREBASE_STORAGE_BUCKET=***
VITE_FIREBASE_MESSAGING_SENDER_ID=***
VITE_FIREBASE_APP_ID=***
VITE_FIREBASE_DATABASE_URL=***
VITE_API_URL=http://localhost:5000
```

## 📊 Performance Considerations

### React Performance
- Use React.memo for expensive components
- Implement proper key props for lists
- Avoid unnecessary re-renders
- Use useCallback and useMemo where appropriate

### Bundle Optimization
- Lazy load components where possible
- Optimize imports to reduce bundle size
- Use code splitting for large components
- Minimize third-party dependencies

### API Performance
- Implement request caching
- Add loading states for better UX
- Handle slow network connections
- Optimize API call frequency

## 🐛 Debugging Guidelines

### Console Logging
- Use console.log for debugging (remove in production)
- Log important state changes
- Log API request/response cycles
- Use consistent log format

### Error Handling
- Implement error boundaries for React errors
- Handle API errors gracefully
- Show user-friendly error messages
- Log errors for debugging

### Development Tools
- Use React Developer Tools
- Use browser network tab for API debugging
- Use Firebase console for authentication debugging
- Use browser console for JavaScript errors

## 🔄 Refactoring Priorities

### Immediate Improvements
1. **Break down App.jsx** into smaller components
2. **Extract reusable components** (Button, Input, Modal, etc.)
3. **Implement proper styling** (CSS modules or styled-components)
4. **Add error boundaries** for better error handling
5. **Improve form validation** and user feedback

### Component Structure
```jsx
// Target component structure
src/
├── components/
│   ├── Auth/
│   │   ├── LoginForm.jsx
│   │   ├── SignupForm.jsx
│   │   └── AuthProvider.jsx
│   ├── Projects/
│   │   ├── ProjectList.jsx
│   │   ├── ProjectCard.jsx
│   │   ├── ProjectForm.jsx
│   │   └── ProjectEdit.jsx
│   ├── Submissions/
│   │   ├── SubmissionList.jsx
│   │   ├── SubmissionCard.jsx
│   │   ├── SubmissionForm.jsx
│   │   └── CodeViewer.jsx
│   └── common/
│       ├── Button.jsx
│       ├── Input.jsx
│       ├── Modal.jsx
│       └── Loading.jsx
```

## 📚 Documentation Standards

### Code Comments
- Add JSDoc comments for complex functions
- Explain business logic clearly
- Document component props and state
- Include usage examples

### Component Documentation
- Document component purpose and usage
- List required and optional props
- Include examples of component usage
- Document state management patterns

## ⚠️ Common Pitfalls to Avoid

### React Issues
- Don't mutate state directly
- Don't forget to add key props to lists
- Don't ignore useEffect dependencies
- Don't create components in render functions

### Performance Issues
- Don't make unnecessary API calls
- Don't ignore bundle size
- Don't forget to implement loading states
- Don't ignore mobile responsiveness

### Security Issues
- Don't expose sensitive data in UI
- Don't trust user input without validation
- Don't ignore authentication state
- Don't skip error handling

### Code Quality Issues
- Don't create overly large components
- Don't duplicate code - extract reusable components
- Don't ignore accessibility guidelines
- Don't forget to test user interactions

## 🎯 Success Metrics

### Code Quality
- Components are focused and single-purpose
- Consistent styling and design patterns
- Proper error handling and loading states
- Good user experience and accessibility

### Performance
- Fast initial load times
- Smooth user interactions
- Efficient API usage
- Responsive design across devices

### User Experience
- Intuitive navigation and interactions
- Clear error messages and feedback
- Consistent design language
- Accessible to all users

## 🔧 Development Tools

### Recommended Extensions
- ESLint for code linting
- Prettier for code formatting
- React Developer Tools
- Firebase Emulator for local development

### Build Process
- Use Vite for fast development builds
- Implement proper environment configuration
- Add build optimization for production
- Include source maps for debugging

## 🚀 Deployment Considerations

### Environment Configuration
- Separate development and production environments
- Use environment variables for configuration
- Implement proper build process
- Add health checks and monitoring

### Performance Optimization
- Implement code splitting
- Optimize bundle size
- Add caching strategies
- Monitor performance metrics 